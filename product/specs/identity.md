# Identity

This doc highlights the goal of defining identity and from that establishing trust in a system

## Overview

Strong identity which can be traced back to the source of creation provides us a way to 
verify and trust users and services. We currently do not have strong identity but 
instead just generate accounts as needed through the runtime.

This proposal starts by defining what identity is and how it can be verified.

## Design

### Account

Identity starts with an Account with a unique ID, name, issuer, type and host

- ID - a UUID that is unique for system in which the user or service exists
- Name - the name to which this identity is provided
- Issuer - the author of this account whether it be another account, system or namespace
- Type - whether this is a user or service account or something else
- Host - the location where this account resides

From this we should be able to extrapolate a common URI string which acts as a unique 
identifier for all users and services.

```
# [provider]://[name]@[host]/[issuer]/[id]

micro://alice@m3o.com/project-borg/f1799136-f3a6-11ea-adc1-0242ac120002
```

The Account is generated by a request made to the auth service for a new account.

### Verification

An account should be traceable and verifiable. Accounts should only be created by the 
auth service in which case auth becomes an identity, authentication and authorization 
provider. 

Account tokens should be signed by the auth service so that others can verify the validity 
in a decentralised manner without having to go back and constantly ask the auth service.

### Mutual TLS

Account URIs form the basis for an identity that can be used to generate x509 certs and 
do mutual TLS. This ensures that all communication between all users and services 
is encrypted.

Each service should generate a certificate signing request (csr) and public/private keypair. 
The csr along with the public key should be sent to the auth service at the time of 
account creation. The auth service will verify the csr, store and sign the public key 
as part of the account. 

When any service talks to any other, it's able to use the auth service as a CA to 
determine the certs for a particulate service to be used as part of MTLS.

Consul connect has a good overview and crypto/tls.Config supports setting a GetClientCertificate 
func.

## Caveats

There may be a simpler approach or a way to offload this work for MTLS but in reality 
strong identity is a building block for everything. It's important to be able to secure, verify 
and rotate accounts/certs automatically.
